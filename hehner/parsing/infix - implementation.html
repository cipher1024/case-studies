<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title></title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="949.54">
  <style type="text/css">
    p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica}
    p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; min-height: 14.0px}
    span.Apple-tab-span {white-space:pre}
  </style>
</head>
<body>
<p class="p1">(0)<span class="Apple-tab-span">	</span>L1.[ word ]</p>
<p class="p1">(1)<span class="Apple-tab-span">	</span>L1.( x &lt;- op &lt;- word ) <span class="Apple-converted-space">  </span>== <span class="Apple-converted-space">  </span>L1.x</p>
<p class="p1">(2)<span class="Apple-tab-span">	</span>L2.x <span class="Apple-converted-space">  </span>== <span class="Apple-converted-space">  </span>L1.( x &lt;- word )</p>
<p class="p1">(3)<span class="Apple-tab-span">	</span>x = word<span class="Apple-converted-space">  </span>\/<span class="Apple-converted-space">  </span>x = op<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>("Alphabet")</p>
<p class="p2"><br></p>
<p class="p1">We start with the invariant J1 that states that we build a string `x' for which we know at each moment whether or not it is part of the language.<span class="Apple-converted-space">  </span>c, the output, stands for that knowledge.</p>
<p class="p2"><br></p>
<p class="p1">J1:<span class="Apple-tab-span">	</span>c == L1.x</p>
<p class="p2"><br></p>
<p class="p1">We use ' on J1 to mention that we are talking about the values of the state variables in a different state. <span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-tab-span">	</span>J1'</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{<span class="Apple-converted-space">  </span>}</p>
<p class="p1"><span class="Apple-tab-span">	</span>c' = L1.x'</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ P2: x' = x &lt;- y }</p>
<p class="p1"><span class="Apple-tab-span">	</span>c' = L1.( x &lt;- y )</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ Alphabet }</p>
<p class="p1"><span class="Apple-tab-span">	</span>c' = L1.( x &lt;- y ) <span class="Apple-converted-space">  </span>/\ <span class="Apple-converted-space">  </span>( y = word<span class="Apple-converted-space">  </span>\/<span class="Apple-converted-space">  </span>y = op )</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ Distributivity of /\ over \/ }</p>
<p class="p1"><span class="Apple-tab-span">	</span>( c' = "L1.( x &lt;- word )"<span class="Apple-converted-space">  </span>/\<span class="Apple-converted-space">  </span>y = word ) <span class="Apple-converted-space">  </span>\/ <span class="Apple-converted-space">  </span>( c' = "L1.( x &lt;- op )"<span class="Apple-converted-space">  </span>/\<span class="Apple-converted-space">  </span>y = op )</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ (2) and (4); see below }</p>
<p class="p1"><span class="Apple-tab-span">	</span>( c' = L2.x<span class="Apple-converted-space">  </span>/\<span class="Apple-converted-space">  </span>y = word )<span class="Apple-converted-space">  </span>\/<span class="Apple-converted-space">  </span>( c' = <b>false</b><span class="Apple-converted-space">  </span>/\<span class="Apple-converted-space">  </span>y = op )</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ J2:<span class="Apple-converted-space">  </span>d == L2.x }</p>
<p class="p1"><span class="Apple-tab-span">	</span>( c' = d<span class="Apple-converted-space">  </span>/\<span class="Apple-converted-space">  </span>y = word )<span class="Apple-converted-space">  </span>\/<span class="Apple-converted-space">  </span>( c' = <b>false</b><span class="Apple-converted-space">  </span>/\<span class="Apple-converted-space">  </span>y = op )</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ Let's call it P1 }</p>
<p class="p1"><span class="Apple-tab-span">	</span>P1</p>
<p class="p2"><br></p>
<p class="p1">The previous calculation of program P1 needs (4) which is not obviously entailed by our assumptions about the language but it still fits: no expressions with infix only operators can terminate with an operator.</p>
<p class="p2"><br></p>
<p class="p1">(4)<span class="Apple-tab-span">	</span>L1.( x &lt;- op ) = <b>false</b></p>
<p class="p2"><br></p>
<p class="p1"><b>Where are we headed?</b><span class="Apple-converted-space"> </span></p>
<p class="p1">We derived program P1 as one that preserves invariant J1.<span class="Apple-converted-space">  </span>The actual proof obligation for this is:</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-tab-span">	</span>J /\ P<span class="Apple-converted-space">  </span>==&gt;<span class="Apple-converted-space">  </span>J'</p>
<p class="p2"><br></p>
<p class="p1">It can be understood as:</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-tab-span">	</span>"If J holds on the value of the variable of the initial state and that P describes a property that holds between the initial values of the variables and their final values, J should hold about their final value."</p>
<p class="p2"><br></p>
<p class="p1">We proved J1' == P1 under the hypothesis J2 and P2.<span class="Apple-converted-space">  </span>We know that adding hypothesis J1 would not harm the validity of the proof and we will say that we proved J1 /\ J2 /\ P2<span class="Apple-converted-space">  </span>==&gt;<span class="Apple-converted-space">  </span>( P1 == J1' ). <span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-tab-span">	</span>J1 /\ J2 /\ P2<span class="Apple-converted-space">  </span>==&gt;<span class="Apple-converted-space">  </span>" ( P1 == J1' ) "</p>
<p class="p1">==&gt;<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ Propositional calculus ( A == B ) ==&gt; ( A ==&gt; B ) }</p>
<p class="p1"><span class="Apple-tab-span">	</span>J1 /\ J2 /\ P2<span class="Apple-converted-space">  </span>==&gt;<span class="Apple-converted-space">  </span>( P1 ==&gt; J1' )</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ Shunting }</p>
<p class="p1"><span class="Apple-tab-span">	</span>J1 /\ J2 /\ P1 /\ P2<span class="Apple-converted-space">  </span>==&gt;<span class="Apple-converted-space">  </span>J1'</p>
<p class="p2"><br></p>
<p class="p1">The invariant we rely on is stronger than that which we are enforcing.<span class="Apple-converted-space">  </span>To progress, we need to strengthen P1 /\ P2 to allow us to preserve J2.</p>
<p class="p1"><b>end of orientation</b></p>
<p class="p2"><br></p>
<p class="p1">We introduced J2, which we will adopt as an invariant, and d, which we will adopt as a boolean state variable.<span class="Apple-converted-space">  </span>Let's see how we can preserve J2.<span class="Apple-converted-space">  </span>For this, we will assume J1, J2, P1 and P2.</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-tab-span">	</span>J2'</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ }</p>
<p class="p1"><span class="Apple-tab-span">	</span>d' = L2.x'</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ P2 }</p>
<p class="p1"><span class="Apple-tab-span">	</span>d' = L2.( x &lt;- y )</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ Alphabet }</p>
<p class="p1"><span class="Apple-tab-span">	</span>( y = word<span class="Apple-converted-space">  </span>\/<span class="Apple-converted-space">  </span>y = op ) <span class="Apple-converted-space">  </span>/\ <span class="Apple-converted-space">  </span>d' = L2.( x &lt;- y )</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ Distributivity }</p>
<p class="p1"><span class="Apple-tab-span">	</span>( y = word<span class="Apple-converted-space">  </span>/\<span class="Apple-converted-space">  </span>d' = " L2.( x &lt;- word ) " ) <span class="Apple-converted-space">  </span>\/ <span class="Apple-converted-space">  </span>( y = op<span class="Apple-converted-space">  </span>/\<span class="Apple-converted-space">  </span>d' = " L2.( x &lt;- op ) " )</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ (5) and (6); see below }</p>
<p class="p1"><span class="Apple-tab-span">	</span>( y = word<span class="Apple-converted-space">  </span>/\<span class="Apple-converted-space">  </span>d' = <b>false </b>) <span class="Apple-converted-space">  </span>\/ <span class="Apple-converted-space">  </span>( y = op<span class="Apple-converted-space">  </span>/\<span class="Apple-converted-space">  </span>d' = L1.x )</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ J1 }</p>
<p class="p1"><span class="Apple-tab-span">	</span>( y = word<span class="Apple-converted-space">  </span>/\<span class="Apple-converted-space">  </span>d' = <b>false </b>) <span class="Apple-converted-space">  </span>\/ <span class="Apple-converted-space">  </span>( y = op<span class="Apple-converted-space">  </span>/\<span class="Apple-converted-space">  </span>d' = c )</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ Let's call it P3 }</p>
<p class="p1"><span class="Apple-tab-span">	</span>P3</p>
<p class="p2"><br></p>
<p class="p1">(5)<span class="Apple-tab-span">	</span>L2.( x &lt;- word ) == <b>false</b></p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-tab-span">	</span>The proposition (5) does<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p1">(6)<span class="Apple-tab-span">	</span>L2.( x &lt;- op ) == L1.x</p>
<p class="p2"><br></p>
<p class="p1"><b>proof</b></p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-tab-span">	</span>L2.( x &lt;- op )</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ (2) }</p>
<p class="p1"><span class="Apple-tab-span">	</span>L1.( x &lt;- op &lt;- word )</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ (1) }</p>
<p class="p1"><span class="Apple-tab-span">	</span>L1.x</p>
<p class="p2"><br></p>
<p class="p1"><b>end</b></p>
<p class="p2"><b></b><br></p>
<p class="p1"><span class="Apple-tab-span">	</span>We see that P1 and P3 have the same shape and we will merge them together.<span class="Apple-converted-space">  </span>We will name their constituent to make the calculations simpler.</p>
<p class="p2"><br></p>
<p class="p1">G1:<span class="Apple-tab-span">	</span>y = word</p>
<p class="p1">G2:<span class="Apple-tab-span">	</span>y = op</p>
<p class="p2"><br></p>
<p class="p1">Q1:<span class="Apple-tab-span">	</span>c' = d</p>
<p class="p1">Q2:<span class="Apple-tab-span">	</span>c' = <b>false</b></p>
<p class="p1">Q3:<span class="Apple-tab-span">	</span>d' = <b>false</b></p>
<p class="p1">Q4:<span class="Apple-tab-span">	</span>d' = c</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-tab-span">	</span>P1<span class="Apple-converted-space">  </span>/\<span class="Apple-converted-space">  </span>P3</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ Expand P1 }</p>
<p class="p1"><span class="Apple-tab-span">	</span>( ( G1 /\ Q1 )<span class="Apple-converted-space">  </span>\/<span class="Apple-converted-space">  </span>( G2 /\ Q2 ) )<span class="Apple-converted-space">  </span>/\<span class="Apple-converted-space">  </span>P3</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ Distributivity }</p>
<p class="p1"><span class="Apple-tab-span">	</span>"( G1 /\ Q1 /\ P3 )"<span class="Apple-converted-space">  </span>\/<span class="Apple-converted-space">  </span>"( G2 /\ Q2 /\ P3 )"</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ (7) and (8); see below }</p>
<p class="p1"><span class="Apple-tab-span">	</span>( G1 /\ Q1 /\ Q3 ) \/ ( G2 /\ Q2 /\ Q4 )</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ Let's now call it P4 }</p>
<p class="p1"><span class="Apple-tab-span">	</span>P4</p>
<p class="p2"><br></p>
<p class="p1">(7)</p>
<p class="p1"><span class="Apple-tab-span">	</span>G1 /\ Q1 /\ P3</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ Expand P3 }</p>
<p class="p1"><span class="Apple-tab-span">	</span>G1 /\ Q1 /\ ( ( G1 /\ Q3 ) \/ ( G2 /\ Q4 ) )</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ Distributivity }</p>
<p class="p1"><span class="Apple-tab-span">	</span>( G1 /\ Q1 /\ Q3 ) \/ ( "G1 /\ G2" /\ Q1 /\ Q4 )</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ (9); see below }</p>
<p class="p1"><span class="Apple-tab-span">	</span>G1 /\ Q1 /\ Q3</p>
<p class="p2"><br></p>
<p class="p1">(8)<span class="Apple-tab-span">	</span>Analogous to (7)</p>
<p class="p2"><br></p>
<p class="p1">In the "Alphabet" postulate, we did not mention that "word" and "op" are different tokens so we add a separate postulate here.</p>
<p class="p2"><br></p>
<p class="p1">(9)<span class="Apple-tab-span">	</span>x = word /\ x = op<span class="Apple-converted-space">    </span>==<span class="Apple-converted-space">    </span><b>false</b></p>
<p class="p2"><br></p>
<p class="p1">The loop body that we have so far is:</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-tab-span">	</span>P2<span class="Apple-converted-space">  </span>/\<span class="Apple-converted-space">  </span>P4</p>
<p class="p1">=</p>
<p class="p1"><span class="Apple-tab-span">	</span>|[<span class="Apple-tab-span">	</span><span class="Apple-converted-space">    </span><b>if</b> y = word -&gt; c, d := d, <b>false</b></p>
<p class="p1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-converted-space">    </span>[] y = op -&gt; c, d := <b>false</b>, c</p>
<p class="p1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-converted-space">    </span><b>fi</b><span class="Apple-converted-space"> </span></p>
<p class="p1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>||<span class="Apple-converted-space">  </span>x := x &lt;- y</p>
<p class="p1"><span class="Apple-tab-span">	</span>|<span class="Apple-tab-span">	</span>x, c, d</p>
<p class="p1"><span class="Apple-tab-span">	</span>]|</p>
<p class="p2"><br></p>
<p class="p1"><b>Note</b>: The previous brackets |[<span class="Apple-converted-space">  </span>_<span class="Apple-converted-space">  </span>|<span class="Apple-converted-space">  </span>_ ]| is an attempt at a clear notation to state what are the variables that the enclosing code is operating on.</p>
<p class="p1"><b>end of note</b></p>
<p class="p2"><br></p>
<p class="p1">With respect to variables, y is mentioned in the program but never assigned to.<span class="Apple-converted-space">  </span>We could make it a global constant but that would make the program rather pointless.<span class="Apple-converted-space">  </span>Instead, we will make it a local arbitrary constant.<span class="Apple-converted-space">  </span>In the logic, this is done like this:</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-tab-span">	</span>( <b>E</b> y:: P2 /\ P4 )</p>
<p class="p2"><br></p>
<p class="p1">Which is already <b>true</b> anyway since we made no assumptions on y and word is a Token.<span class="Apple-converted-space">  </span>We note it in the code as:</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-tab-span">	</span><b>any</b> y<b> in</b></p>
<p class="p1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-converted-space">    </span><b>if</b> y = word -&gt; c, d := d, <b>false</b></p>
<p class="p1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-converted-space">    </span>[] y = op -&gt; c, d := <b>false</b>, c</p>
<p class="p1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-converted-space">    </span><b>fi</b></p>
<p class="p1"><b><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></b>||<span class="Apple-converted-space">  </span>x := x &lt;- y</p>
<p class="p1"><span class="Apple-tab-span">	</span><b>yna</b></p>
<p class="p2"><br></p>
<p class="p1">If the range of the existential quantification had been non-empty, we could have put a clause between `y' and <b>in</b> labeled <b>where</b> and put a guard there.</p>
<p class="p2"><br></p>
<p class="p1"><b>Note</b> The termination of the <b>any</b> construct with a <b>yna</b> keyword is a notational experiment.<span class="Apple-converted-space">  </span>I took the <b>any</b> construct from B and gave it a meaning in the context of Hehner's calculus.<span class="Apple-converted-space">  </span>In B, however, the construct is concluded with an <b>end </b>keyword which, I feel, does not fit well with the guarded command construct.<span class="Apple-converted-space">  </span>Admittedly, I could terminate the <b>if</b> and the <b>do</b> loop with an end keyword but I would then have to change the arrow separating a guard and its associated command for another keyword.<span class="Apple-converted-space">  </span><b>then </b>might do the trick but I'm not sure I want to loose the symmetry of the syntax which allows me to treat <b>if</b> and <b>do</b> as braces and does not hint at a correct order of reading.<span class="Apple-converted-space">  </span><b>end of note</b></p>
<p class="p2"><br></p>
<p class="p1">We should quickly think about initialization.<span class="Apple-converted-space">  </span>A very simple way of doing so is to start with:</p>
<p class="p2"><br></p>
<p class="p1">P5:<span class="Apple-tab-span">	</span>x = []</p>
<p class="p2"><br></p>
<p class="p1">We will now calculate initialization for c and d by substituting any reference to symbolic functions for expressions that are computable.</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-tab-span">	</span>J1</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{<span class="Apple-converted-space">  </span>}</p>
<p class="p1"><span class="Apple-tab-span">	</span>c = L1." x "</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ P5 }</p>
<p class="p1"><span class="Apple-tab-span">	</span>c = " L1.[] "</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ (10) see below }</p>
<p class="p1"><span class="Apple-tab-span">	</span>c = <b>false</b></p>
<p class="p1">=<span class="Apple-tab-span">	</span>P6</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-tab-span">	</span>J2</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ }</p>
<p class="p1"><span class="Apple-tab-span">	</span>d = L2." x "</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ P5 }</p>
<p class="p1"><span class="Apple-tab-span">	</span>d = " L2.[] "</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ (2) with x := [] }</p>
<p class="p1"><span class="Apple-tab-span">	</span>d = " L1.[word] "</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ (0) }</p>
<p class="p1"><span class="Apple-tab-span">	</span>d = <b>true</b></p>
<p class="p1">=<span class="Apple-tab-span">	</span>P7</p>
<p class="p2"><br></p>
<p class="p1">Therefore, starting in a state that satisfy P5 /\ P6 /\ P7 will establish the invariant J1 /\ J2</p>
<p class="p2"><br></p>
<p class="p1">For now, the code does not mention termination.<span class="Apple-converted-space">  </span>It could be convenient to consider what we have so far as a protocol to be executed by a process reading tokens on a channel and offering as a service a boolean query stating whether or not the string constructed so far is a valid expression or not.<span class="Apple-converted-space">  </span>The other end of its channel could be plugged on a text box in which a user types some text.<span class="Apple-converted-space">  </span>If it was the case, the protocol would be usable as it is.<span class="Apple-converted-space">  </span>However, we will consider the investigation because accepting a string given as a parameter is a credible usage and we need to be able to get a result eventually if we are using the program this way.</p>
<p class="p2"><br></p>
<p class="p1">We will consider S to be that input.<span class="Apple-converted-space">  </span>Since we want to be accepting S, we will be constructing `x' in such a way that it eventually becomes equal to S.<span class="Apple-converted-space">  </span>To make the situation more symmetric, we will introduce a name for the remainder of the string.<span class="Apple-converted-space">  </span>Let it be `z'.</p>
<p class="p2"><br></p>
<p class="p1">J3:<span class="Apple-tab-span">	</span>x ++ z = S</p>
<p class="p2"><br></p>
<p class="p1">Let's see now see if we can maintain it.</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-tab-span">	</span>J3'</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{<span class="Apple-converted-space">  </span>}</p>
<p class="p1"><span class="Apple-tab-span">	</span>x' ++ z' = S</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ P2 }</p>
<p class="p1"><span class="Apple-tab-span">	</span>x &lt;- y ++ z' = S</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ Sequence theory }</p>
<p class="p1"><span class="Apple-tab-span">	</span>x ++ y -&gt; z' = S</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ P8: z' = w; get the expression back in terms of pre-state }</p>
<p class="p1"><span class="Apple-tab-span">	</span>x ++ y -&gt; w = S</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ G3: y -&gt; w = z }</p>
<p class="p1"><span class="Apple-tab-span">	</span>x ++ z = S</p>
<p class="p1">=<span class="Apple-tab-span">	</span>J3</p>
<p class="p2"><br></p>
<p class="p1">Let's now give a name to the body of the loop:</p>
<p class="p2"><br></p>
<p class="p1">P9:<span class="Apple-tab-span">	</span>( <b>E</b> y, w:<span class="Apple-converted-space">  </span>G3:<span class="Apple-converted-space">  </span>P2<span class="Apple-converted-space">  </span>/\<span class="Apple-converted-space">  </span>P4<span class="Apple-converted-space">  </span>/\<span class="Apple-converted-space">  </span>P8 )</p>
<p class="p2"><br></p>
<p class="p1">So far, we proved</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-tab-span">	</span>G3 /\ P8 /\ P2<span class="Apple-converted-space">  </span>==&gt;<span class="Apple-converted-space">  </span>( J3<span class="Apple-converted-space">  </span>==<span class="Apple-converted-space">  </span>J3' )</p>
<p class="p2"><br></p>
<p class="p1">And, with the regular shunting argument, we conclude that G3 /\ P8 /\ P2 is the body of a loop which preserves J3.<span class="Apple-converted-space">  </span>We can investigate what values of z is suitable for starting the loop:</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-tab-span">	</span>J3</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ Expand }</p>
<p class="p1"><span class="Apple-tab-span">	</span>x ++ z = S</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ P5 }</p>
<p class="p1"><span class="Apple-tab-span">	</span>[] ++ z = S</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ Sequence theory }</p>
<p class="p1"><span class="Apple-tab-span">	</span>z = S</p>
<p class="p1">=<span class="Apple-tab-span">	</span>P10</p>
<p class="p2"><br></p>
<p class="p1">Here is an interesting twist (at least, having done the development in different shapes before, I did not expect it):<span class="Apple-converted-space">  </span>if we try to prove that the body of the loop is executable, that is, if we try to see if we can find a final value for every program variable, we come down to a condition on which the execution rely.</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-tab-span">	</span>( <b>E</b> y, w, x', z', c', d':: G3<span class="Apple-converted-space">  </span>/\<span class="Apple-converted-space">  </span>P4<span class="Apple-converted-space">  </span>/\<span class="Apple-converted-space">  </span>P8<span class="Apple-converted-space">  </span>/\<span class="Apple-converted-space">  </span>P2 )</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ Trading }</p>
<p class="p1"><span class="Apple-tab-span">	</span>( <b>E</b> y, w, x', z', c', d':<span class="Apple-converted-space">  </span>x' = x &lt;- y:<span class="Apple-converted-space">  </span>G3<span class="Apple-converted-space">  </span>/\<span class="Apple-converted-space">  </span>P4<span class="Apple-converted-space">  </span>/\<span class="Apple-converted-space">  </span>P8 )</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ One point rule: x' does not appear in the term;</p>
<p class="p1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Trading }</p>
<p class="p1"><span class="Apple-tab-span">	</span>( <b>E</b> y, w, z', c', d':<span class="Apple-converted-space">  </span>z' = w:<span class="Apple-converted-space">  </span>G3<span class="Apple-converted-space">  </span>/\<span class="Apple-converted-space">  </span>P4 )</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ One point rule: z' does not appear in the term;</p>
<p class="p1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Trading; Distributivity }</p>
<p class="p1"><span class="Apple-tab-span">	</span>" ( <b>E</b> y, w, c', d':<span class="Apple-converted-space">  </span>G3:<span class="Apple-converted-space">  </span>G1<span class="Apple-converted-space">  </span>/\<span class="Apple-converted-space">  </span>Q1<span class="Apple-converted-space">  </span>/\<span class="Apple-converted-space">  </span>Q3 ) "<span class="Apple-converted-space">  </span>\/<span class="Apple-converted-space">  </span>" ( <b>E</b> y, w, c', d':<span class="Apple-converted-space">  </span>G3:<span class="Apple-converted-space">  </span>G2<span class="Apple-converted-space">  </span>/\<span class="Apple-converted-space">  </span>Q2<span class="Apple-converted-space">  </span>/\<span class="Apple-converted-space">  </span>Q4 ) "</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ Trading, twice }</p>
<p class="p1"><span class="Apple-tab-span">	</span>" ( <b>E</b> y, w, c', d':<span class="Apple-converted-space">  </span>Q1<span class="Apple-converted-space">  </span>/\<span class="Apple-converted-space">  </span>Q3:<span class="Apple-converted-space">  </span>G1<span class="Apple-converted-space">  </span>/\<span class="Apple-converted-space">  </span>G3 ) "<span class="Apple-converted-space">  </span>\/<span class="Apple-converted-space">  </span>" ( <b>E</b> y, w, c', d':<span class="Apple-converted-space">  </span>Q2<span class="Apple-converted-space">  </span>/\<span class="Apple-converted-space">  </span>Q4:<span class="Apple-converted-space">  </span>G2<span class="Apple-converted-space">  </span>/\<span class="Apple-converted-space">  </span>G3 ) "</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ One point rule, twice }</p>
<p class="p1"><span class="Apple-tab-span">	</span>( <b>E </b>y, w::<span class="Apple-converted-space">  </span>G1<span class="Apple-converted-space">  </span>/\<span class="Apple-converted-space">  </span>G3 )<span class="Apple-converted-space">  </span>\/<span class="Apple-converted-space">  </span>( <b>E</b> y, w::<span class="Apple-converted-space">  </span>G2<span class="Apple-converted-space">  </span>/\<span class="Apple-converted-space">  </span>G3 )</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ Distributivity twice }</p>
<p class="p1"><span class="Apple-tab-span">	</span>( <b>E</b> y, w::<span class="Apple-converted-space">  </span>G3<span class="Apple-converted-space">  </span>/\<span class="Apple-converted-space">  </span>(G1<span class="Apple-converted-space">  </span>\/<span class="Apple-converted-space">  </span>G2) )</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ Alphabet }</p>
<p class="p1"><span class="Apple-tab-span">	</span>( <b>E </b>y, w::<span class="Apple-converted-space">  </span>y -&gt; w = z )</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ Sequence theory }</p>
<p class="p1"><span class="Apple-tab-span">	</span>z ≠ []</p>
<p class="p2"><br></p>
<p class="p1">We now see that the body of the loop is only executable provided z /= [] whose negation is a great candidate for a termination condition since we get the following postcondition from the invariant:</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-tab-span">	</span>J3</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ Expand }</p>
<p class="p1"><span class="Apple-tab-span">	</span>x ++ z = S</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ ¬ G3 }</p>
<p class="p1"><span class="Apple-tab-span">	</span>x = S</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ J1 }</p>
<p class="p1"><span class="Apple-tab-span">	</span>x = S<span class="Apple-converted-space">  </span>/\<span class="Apple-converted-space">  </span>c = L1.x</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ Leibniz }</p>
<p class="p1"><span class="Apple-tab-span">	</span>x = S<span class="Apple-converted-space">  </span>/\<span class="Apple-converted-space">  </span>c = L1.S</p>
<p class="p2"><br></p>
<p class="p1">For the final touch, we can prove the termination by finding a variant.<span class="Apple-converted-space">  </span>We know that sequences admit a well-founded order.<span class="Apple-converted-space">  </span>There are many ways in which we could define such an order but it turns out that we need very little details for our proof.<span class="Apple-converted-space">  </span>The variant that we choose is `z' and we will now prove that the body of the loop refines z /= []<span class="Apple-converted-space">  </span>==&gt;<span class="Apple-converted-space">  </span>z' &lt; z. <span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p1">Since there's only one assignment affecting z and that it is in a monotonic context with respect to implication, we will start our derivation with it.</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>z' &lt; z</p>
<p class="p1"><span class="Apple-tab-span">	</span>=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ P8 }</p>
<p class="p1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>w &lt; z</p>
<p class="p1"><span class="Apple-tab-span">	</span>=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ G3 }</p>
<p class="p1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>w<span class="Apple-converted-space">  </span>&lt;<span class="Apple-converted-space">  </span>y -&gt; w</p>
<p class="p1"><span class="Apple-tab-span">	</span>=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ (10) see below }</p>
<p class="p1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>true</b></p>
<p class="p2"><br></p>
<p class="p1">We needed (10) to complete our proof.</p>
<p class="p2"><br></p>
<p class="p1">(10)<span class="Apple-tab-span">	</span>b <span class="Apple-converted-space">  </span>&lt; <span class="Apple-converted-space">  </span>a -&gt; b</p>
<p class="p2"><br></p>
<p class="p1">This states that prepending an item on a sequence makes it bigger.<span class="Apple-converted-space">  </span>To make sure that this is a partial order, we can strengthen its specification and say that all that matters for the order is the size of the sequence.</p>
<p class="p2"><br></p>
<p class="p1">(11)<span class="Apple-tab-span">	</span>#b &lt; #c<span class="Apple-converted-space">    </span>==<span class="Apple-converted-space">    </span>b &lt; c</p>
<p class="p2"><br></p>
<p class="p1">This is clearly a well-founded order.<span class="Apple-converted-space">  </span>From here we can derive (10).</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-tab-span">	</span>b <span class="Apple-converted-space">  </span>&lt; <span class="Apple-converted-space">  </span>a -&gt; b</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ (11) }</p>
<p class="p1"><span class="Apple-tab-span">	</span>#b <span class="Apple-converted-space">  </span>&lt; <span class="Apple-converted-space">  </span>#( a -&gt; b )</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ Sequence theory }</p>
<p class="p1"><span class="Apple-tab-span">	</span>#b <span class="Apple-converted-space">  </span>&lt; <span class="Apple-converted-space">  </span>1 + #b</p>
<p class="p1">=<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ Arithmetic }</p>
<p class="p1"><span class="Apple-tab-span">	</span><b>true</b></p>
<p class="p2"><br></p>
<p class="p1">We could have defined our well-founded order in many different ways as long as we could have derived (10) from it, it would have been sufficient.</p>
<p class="p2"><br></p>
<p class="p1">Hence, we proved termination and we can see that</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">  </span>x, z, c, d := [], S, <b>false</b>, <b>true</b></p>
<p class="p1"><span class="Apple-tab-span">	</span>; <b>while</b> z /= [] <b>do</b></p>
<p class="p1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>any</b> y, w <b>where</b></p>
<p class="p1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>y -&gt; w = z</p>
<p class="p1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>in</b></p>
<p class="p1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span> <span class="Apple-converted-space">  </span><b>if</b> y = word -&gt; c, d := d, <b>false</b></p>
<p class="p1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span> <span class="Apple-converted-space">  </span>[] y = op -&gt; c, d := <b>false</b>, d</p>
<p class="p1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span> <span class="Apple-converted-space">  </span><b>fi</b></p>
<p class="p1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>|| x := x &lt;- y</p>
<p class="p1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>|| z := w</p>
<p class="p1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>yna</b></p>
<p class="p1"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">  </span><b>od</b></p>
<p class="p2"><br></p>
<p class="p1">ensures c == L1.S.<span class="Apple-converted-space">  </span>As a concluding note, we would like to remark that the choice of variables is merely for manipulative convenience: instead of keeping one explicit array with an index splitting it at the end of x and use a complex abstraction function for x and z, we named explicitly the values of interest in the invariant while leaving the freedom to the eventual implementor to use a variable change and obtain a more efficient data structure.<span class="Apple-converted-space">  </span>The emphasis here is that the important role of the variables is not that they denote values stored in the memory but that they represent values of interest to make the argument simple.</p>
</body>
</html>
