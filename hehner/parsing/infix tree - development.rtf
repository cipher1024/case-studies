{\rtf1\ansi\ansicpg1252\cocoartf949\cocoasubrtf540
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\paperw11900\paperh16840\margl1440\margr1440\vieww9000\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\ql\qnatural\pardirnatural

\f0\fs24 \cf0 We now turn to the problem of building a syntax to turn our acceptor into a parser.  As we did until now, we will keep this extension minimal.  Since we did not provide a way to distinguish operators or words among themselves, we will not keep any information on those.  All the information that we will have will be the shape of the syntax tree.  We will be able to add attributes to the tree when we need the information but we will delay it until then.\
\
Here is the definition of our syntax tree.\
\
tree ^= 	btree (l, r: tree)\
	|	leaf\
\
We will make explicit the assumptions that we make on that structure:\
\
(0)	btree.x.y = btree.w.z    ==    x = w  /\\  y = z\
(1)	btree.x.y \uc0\u8800  leaf\
\
We assume that the tree admits well-founded order:\
\
(2)	x < btree.x.y\
(3)	y < btree.x.y\
(4)	z < x  ==>  z < btree.x.y\
(5)	z < y  ==>  z < btree.x.y\
(6)	( 
\b A
\b0  x:  ( 
\b A
\b0  y:  y < x:  P.y ):  P.x )  ==>  ( 
\b A
\b0  x::  P.x )\
\
Finally, we define the linearization of trees:\
\
(7)	lin.leaf = [ word ]\
(8)	lin.( btree.x.y ) = lin.x ++ [ op ] ++ lin.y\
\
A simple approach to building a tree would be to keep the tree built so far in a variable t and to build a new node every time a word is scanned, as long as the input sting is accepted and assign t := btree.t.leaf.  It has the nice (?) property that it is a deterministic behavior but the class of trees it builds is largely uninteresting.  Instead, we will build a nondeterministic tree building that can build any appropriate syntax tree for a given input.  We defer to later the task of removing the nondeterminacy by introducing an appropriate criterion for choosing the tree that interests us among those that interest us.  At that point, for the ease of use of the language, it will be important that the tree be uniquely associated with the input string and that the choice be based on a very simple criterion.  An acceptable trade-off might be to reject input that the acceptor accepted in order to make the selection simple.\
\
For now, let's say that we will build a stack of trees that has not been aggregated, yet.  So we have two actions to perform on that stack, integrate new words as leaves and aggregate trees.\
\
(9)	ser.[] = []\
(10)	ser.( def <- t ) = ser.def ++ [ op ] ++ lin.t\
\
J1:	c  ==>  ser.def = op -> x\
J2:	d  ==>  ser.( def <- leaf ) = op -> x <- word\
\
(11)		J1'\
	=		\{ P2 \}\
		c'  ==>  ser.def' = op -> x <- y\
	=		\{ G1: y = word \}\
		c'  ==>  ser.def' = op -> x <- word\
	=		\{ P3: def' = def <- leaf \}\
		c'  ==>  ser.( def <- leaf ) = op -> x <- word\
	=		\{ P1: c' = d \}\
		d  ==>  ser.( def <- leaf ) = op -> x <- word\
	=	J2\
\
(12)		J2'\
	=		\{ P2 \}\
		d'  ==>  ser.( def' <- leaf ) = op -> x <- y <- word\
	=		\{ G2: y = op \}\
		d'  ==>  ser.( def' <- leaf ) = op -> x ++ [ op ] ++ [ word ]\
	=		\{ (7), P2: d' = c \}\
		c  ==>  ser.( def' <- leaf ) = op -> x ++ [ op ] ++ lin.leaf\
	=		\{ J1 and P4: def' = def \}\
		c  ==>  ser.( def <- leaf ) = ser.def ++ [ op ] ++ lin.leaf\
	=		\{ (10) \}\
		c  ==> true\
	=	true\
\
We used respectively y = word and y = op as hypotheses in the previous calculations.  What if we had swapped them?  In the conditional of the acceptor, in when y = op, c gets assigned false and when y = word, d gets assigned false so this falsify the premises respectively of J1 and J2 which enforces them.\
\
Before merging, we must notice that both assignments to def are relying on the value of y and a second condition, for which, nothing is specified for in the advent that it would become false.  In order to simplify the program, we will ignore the second conditions.  The effect will be that the program will be over-specific whenever the condition is false.\
Merging this with what we already had for the acceptor of infix expressions, we get:\
\
	if y = word ->\
		c, d, def := d, false, def <- leaf\
	[] y = op ->\
		c, d := false, c\
	fi ||\
	x, z := x <- y, w\
\
If we want to terminate eventually, we need to merge trees from time to time.  Since it affects def and we already specified its final value for both branch, we could append or prepend our join to the program that we already have.  This could become complicated, especially around the termination because, as it stands, the loop terminates at the moment where z is empty.  Instead, we add another alternative that is to join two subtrees.  While one of the two other alternatives is activated whenever z is not empty, joining trees does not need that kind of assumption and will therefore weaken the guard of the loop, therefore strengthening its postcondition.  To merge subtrees, we need at least two trees in the stack.  On the other hand, we need at most one tree upon termination.  When it comes to termination, we can see that the two main branches have their own variants: z and def.  While the second branch does not modify z, the first one grows def so we can't just add the size of the two sequences to obtain a variant.  However, we can consider that (z, def) will be decreased as a tuple if we consider its lexicographical ordering.  We already know that the first branch decreases z, we don't need anything further in that respect.  We'll have to make sure that the second branch does not increase z  --as a matter of fact, it should not need to touch it--  and decreases def.\
\
For the actual code, we will start with the requirement that the serialization of the stack is not changed and that all other variables are not changed either.  Since we want the assign to def nonetheless, we can start with either the final or the initial value of the serialization of def and calculate the value it has as an expression in the other state.  The next derivation has been developed in the reverse order but it has been chosen to present it like this so that u and v are not pulled out of a hat.  However, the reverse order still has the advantage of announcing right away that the goal it to add a subtree.\
\
(13)		ser.def\
	=		\{ G3:  ( 
\b E
\b0  s, u, v::  s <- u <- v = def ) \}\
		ser.( s <- u <- v )\
	=		\{ (10) twice \}\
		ser.s  ++  [ op ]  ++  lin.u  ++  [ op ]  ++  lin.v\
	=		\{ (8) \}\
		ser.s  ++  [ op ]  ++  lin.( btree.u.v )\
	=		\{ (10) \}\
		ser.( s <- btree.u.v )\
	=		\{ P6: def' = s <- btree.u.v \}\
		ser.def'\
\
We then have:\
\
G4:	s <- u <- v = def\
\
P5:	def' = s <- btree.u.v\
P6:	( 
\b E
\b0  s, u, v:  G4:  P5 )\
P7:	c' = 
\b false
\b0 \
P8:	d' = 
\b false
\b0 \
P9:	x' = x <- y\
P10:	z' = w\
P11:	( (G1 /\\ P7 /\\ P1) \\/ (G2 /\\ P8 /\\ P2) ) /\\ P9 /\\ P10\
\
P12:	( P6 /\\ z' = z /\\ x' = x ) \\/ P11\
\
J3:	c == L1.x\
J4: 	d == L2.x\
J5:	x ++ z = S\
\
J6:	J1 /\\ J2 /\\ J3 /\\ J4 /\\ J5\
\
P13:	J6   ==>   [ \'ac G3' ] /\\ J6'\
\
(14)	P13   <==   P12 ; P13\
\
Let's now compute the guard of P6 to confirm our suspicion that upon termination, we have only one tree left if the input word is accepted.\
\
(15)		( 
\b E 
\b0 def'::  P6 )\
	=		\{ Merge quantifications \}\
		( 
\b E
\b0  s, u, v, def':  s <- u <- v = def:  def' = s <- bree.u.v )\
	=		\{ Trading twice, one point rule \}\
		( 
\b E 
\b0 s, u, v::  s <- u <- v = def )\
	=		\{ Split quantification \}\
		( 
\b E
\b0  s::  ( 
\b E
\b0  u, v::  s <- u <- v = def ) )\
	=		\{ Sequence theory \}\
		( 
\b E
\b0  s::  #s + 2 = #def )\
	=		\{ Length of sequence \}\
		#def \uc0\u8805  2\
\
So the loops continues provided #def \uc0\u8805  2   \\/   z \u8800  [] so it terminates when  #def \u8804  1 /\\ z = [].  Therefore, we have at most one tree left.  Good!  We need to have one, at least if the input is accepted though.\
\
(16)		def \uc0\u8800  []\
	<==		\{ Leibniz \}\
		ser.def \uc0\u8800  []\
	<==		\{ Sequence theory \}\
		ser.def = op -> x\
	<==		\{ J1 \}\
		c\
\
With the termination condition, we can now conclude\
\
(17)		( 
\b E
\b0  t::  c   ==>   def = [ t ] )\
\
(18)		op -> S\
	=		\{ J1, J5 with c and z = [] \}\
		ser.def\
	=		\{ (17) \}\
		ser.( [] <- t )\
	=		\{ (10) \}\
		ser.[]  ++ [ op ] ++ lin.t\
	=		\{ (9) \}\
		op -> lin.t\
\
(19)		c\
	==>		\{ J1 \}	\
		ser.def = op -> S\
	=		\{ Sequence theory \}\
		S = lin.t\
\
We mentioned the new variant earlier but did not prove that is decreased.  We will first define the well founded order and then carry the proof for each branch.\
\
(20)	(z, def) < (z', def')    ==    z < z'  \\/  ( z = z' /\\ def < def' )\
\
We here use the principle that a lexicographical order on tuples whose elements admit a well-founded order is itself well-founded.\
\
(21)		(z', def') < (z, def)\
	=		\{ (20) \}\
		z' < z  \\/  ( z' = z  /\\  def' < def )\
	<==		\{ Strengthening \}\
		z' = z  /\\  def' < def\
	=		\{ z' = z \}\
		def' < def\
	=		\{ P5 and G4 \}\
		s <- btree.u.v   <   s <- u <- v\
	=		\{ Sequence theory \}\
		
\b true
\b0 \
\
(22)		(z', def') < (z, def)\
	<==		\{ (20) and strengthening \}\
		z' < z\
	=		\{ P10 \}\
		w < z\
	=		\{ G5 \}\
		w   <   y -> w\
	=		\{ Sequence theory \}\
		
\b true
\b0 \
\
Now, we know that our nondeterministic loop will terminate and produce a syntax tree if the input is correct.  It looks like this:\
\
	c, d, x, z, def := 
\b false
\b0 , 
\b true
\b0 , [], [], S\
	
\b while
\b0  z \uc0\u8800  []   \\/   #def \u8805  2 
\b do
\b0 \
		
\b if
\b0  
\b any
\b0  y, w 
\b where
\b0  y -> w = z 
\b in
\b0 \
			
\b if
\b0  y = word -->\
				c, d, def := d, 
\b false
\b0 , def <- leaf\
			[] y = op ->\
				c, d := 
\b false
\b0 , c\
			
\b fi
\b0 \
			||  x, z := x <- y, w\
		[] 
\b any
\b0  s, u, v 
\b where
\b0  s <- u <- v = def 
\b in
\b0 \
			del := s <- btree.u.v\
		
\b fi
\b0 \
	
\b od
\b0 \
\
It would be interesting now to see if any valid syntax tree can be generated by the parser.  This is because we will want to select particular trees later and we don't have enough information to know which one might be of interest.  We defer this decision to later.\
\
To check this property, we will inverse the program.  That way, we will produce a program that takes a tree and writes it's linearization.\
\
		( G4 /\\ P5 ) [ s', s  :=   s, s' ]\
	=		\{ Substitution \}	\
		s <- u <- v = def'   /\\   def = s <- btree.u.v\
	=	P14 /\\ G6\
\
		P9 /\\ P10 [ s', s   :=   s, s' ]\
	=		\{ Substitution \}\
		x = x' <- y   /\\   z = w\
	=		\{ Variable decomposition \}\
		x' = v  /\\  x = v <- y  /\\  z = w\
	=	P15 /\\ G7 /\\ G8\
\
		G5 [ s', s   :=   s, s' ]\
	=		\{ Substitution \}\
		y -> w = z'\
	=		\{ G8 \}\
		z' = y -> z\
	=	P16\
\
		( G1 /\\ P7 /\\ P1 ) [ s, s'   :=   s', s ]\
	=		\{ Substitution \}\
		y = word  /\\  c = false  /\\  d' = c\
	=		\{ G8: y = word /\\ c = false; P17 \}\
		G8  /\\  P17\
\
		( G2 /\\ P8 /\\ P2 ) [ s, s'   :=    s', s ]\
	=		\{ Substitution \}\
		y = op  /\\  d = false  /\\  c' = d\
	=		\{ G9: y = op /\\ d = false;  P18:  c' = d \}\
		G9 /\\ P18\
\
}