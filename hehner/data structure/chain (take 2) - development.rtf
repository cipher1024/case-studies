{\rtf1\ansi\ansicpg1252\cocoartf949\cocoasubrtf540
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\paperw11900\paperh16840\margl1440\margr1440\vieww9000\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\ql\qnatural\pardirnatural

\f0\fs24 \cf0 Since it enters in the implementation of many data structures, we will derive what we shall call a chain.  It is the data structure composed of cells containing, among other things, pointers to their successor. \
\
It appears so often because it is a very good implementation of sequences with no predefined maximum length.  This is why we use it often to implement lists, stacks and queues.  It can also be handy for sets, once we have refined it into an injective sequence.\
\
After thinking about it on and off for a month or so, I decided to prune any content from the chain and to consider every cell and their tail.  If we want it to be doubly linked, it will then be a simple matter to have two tails for every cell and make them consistent.  We will work with the type C of the cells and introduce right away a predicate over it, 'in', which will distinguish between the cells in the game and those out of it.  It was formerly called 'live' as a reference to usual memory management techniques but starting anew with 'in' instead promises to liberate, at least for a while, from the thoughts that a memory management device may have to allocate the memory somehow.  In the same line of thought, C has been chosen instead of P, which stood for pointer.\
\
In addition to 'in', we will need a function associating a cell to its tail and an invariant stating that the mentioned tail is consistent.  This is stated by the following invariant:\
\
	J1:	( A b, c, q:  tl.b = [c] ++ q:  tl.c = q )\
}