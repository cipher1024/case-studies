\documentclass[10pt]{report}
\usepackage[top=3cm, bottom=2.5cm, left=3cm, right=2.5cm] {geometry}
\geometry{letterpaper}                   % ... or a4paper or a5paper or ... 
%\geometry{landscape}                % Activate for for rotated page geometry
%\usepackage[parfill]{parskip}    % Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{epstopdf}

	% NOTE: It seems strategic to set the proofs repository as a submodule of any repository making
	% 	use of it.  For articles `some_article' and `other_article' it seems sensible to put the directories
	%	`some_article', `other_article' and `packages' (which contains proofs as a submodule) side by
	%	side.
	% (END OF NOTE)
\usepackage{fancyhdr,lastpage,color}
\usepackage{../packages/bsymb}
\usepackage{../packages/b2latex}
\usepackage{../packages/elogic}

\newcommand{\word}{\textbf{word}}
\newcommand{\ID}{\textbf{id}}
\newcommand{\type}[2]{#1 : #2}

\newcounter{i}

\newcommand{\division}[2]{
	\setcounter{i}{1}
%	\ifthenelse{#1 = \value{i}} {
%		\part{#2}
%	} {}
%	\stepcounter{i}
	\ifthenelse{#1 = \value{i}} {
		\chapter{#2}
	} {}
	\stepcounter{i}
	\ifthenelse{#1 = \value{i}} {
		\section{#2}
	} {}
	\stepcounter{i}
	\ifthenelse{#1 = \value{i}} {
		\subsection{#2}
	} {}
	\stepcounter{i}
	\ifthenelse{#1 = \value{i}} {
		\subsubsection{#2}
	} {}
	\stepcounter{i}
	\ifthenelse{#1 = \value{i}} {
		\paragraph{#2}
	} {}
	\stepcounter{i}
	\ifthenelse{#1 = \value{i}} {
		\subparagraph{#2}
	} {}
	\stepcounter{i}
}

\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}

\title{SH60 - The Derivation of a Parser}
\author{Simon Hudon}
%\date{}                                           % Activate to display a given date or no date
\pagestyle{fancy}
\begin{document}
\maketitle
%\section{}
%\subsection{}
%\thispagestyle{empty}

The idea behind this note is to present an experiment similar to that presented in EWD550.  In this note however, the goal is a bit more ambitious.  On one hand, I hope to be able to use the resulting program to parse arbitrary mathematical formulae so I have to support a more complicated grammar.  On the other hand, while I was developing the program, I came across the idea of separating the grammar by feature as a means of simplification of the process.  This is what is usually referred to as "separation of concerns" and I'm expecting very elegant results by following this particular path in this situation.

\division{1}{Binary Operators}

\division{2}{Algorithm}

To be more specific about the goal that the algorithm is expected to fulfill, I want it to take a set of operators as a parameter together with a set of precedence rules and have it parse a formula built from custom unary, binary and quantified operators.  In addition, I would also like to include regular parentheses and custom bracketed operators.  As a first effort, the grammar will be simplified to support only binary operators.  This is the construct that allows the construction of arbitrarily long strings.  The language of immediate interest is generated by the following grammar:

\begin{align}
	Expr \quad ::= & \quad Expr  \ \odot \ Expr  \label{csyntax} \\
		& | \quad \word \nonumber \\
		& \nonumber ;
\end{align}

Although it is a context-free grammar, the language it generates is regular and the feature of interest of the grammar is that it gives the shape of a family of parse trees.  The language can equivalently be generated by the following regular expression:

\[   \textbf{word} \cdot (\odot \cdot \textbf{word} ) ^ {*} \]

For our purpose, the parser for this language will have a dual task:

\begin{enumerate}
	\item Construct the parse tree of any correct input.
	\item Detect any syntax error and mark an incorrect input as such.
\end{enumerate}

We will narrow down the set of acceptable parse trees by adding a precedence relation $\prec$ between operators.  For the operators $p$, $q$,$r$ in the following input:

\[ \word \cdot p \cdot \word \cdot q \cdot \word \cdot r \cdot \word \]

with the following relations between the operators:

\begin{align*}
	q & \prec p \\
	q & \prec r
\end{align*}

$q$ should be located in a subtree of $p$ and $r$.  It is also true if we consider trees instead of the words in the above input.  For now, we make no further assumption about $\prec$.  It follows that the construction of a parse tree is non-deterministic if in

\[
t1 \cdot p \cdot t2 \cdot q \cdot t3
\]

we have

\begin{align*}
	q & \prec p \\
	p & \prec q
\end{align*}

It also follows that the construction of a parse tree can fail even if the syntax of the input is correct.



\division{2}{Data structures}

\division{3}{Syntax Trees}

\division{4}{Variables}
\[
\type{tree}{\textbf{Tree} \tfun \nat }
\]

\division{4}{Initially}
\[
	[ tree.t = 0 ]
\]

\division{4}{Build binary node}

\begin{align*}
& tree.t1 > 0 % \\  & \qquad \qquad 
	\land  tree.t2 > 0  \\ & \qquad \qquad
	\land nt = (BinOp.op.t1.t2) \longrightarrow \\
& \qquad tree.nt := tree.nt + 1
\end{align*}

\division{4}{Build leaves}

\begin{align*}
& nt = Word.w  \longrightarrow \\
& \qquad tree.nt := tree.nt + 1
\end{align*}

\division{4}{Refinement}

\begin{align*}
\type{root}{P \tfun \nat} \\
\type{bins}{\pow (P)} \\
\type{leaves}{\pow (P)} \\
\type{left}{P \tfun P} \\
\type{right}{P \tfun P} \\
\type{op}{P \tfun OPER} \\
\type{w}{P \tfun WORD}
\end{align*}

\division{4}{invariant}

\begin{align*}
	[\neg (bins.x & \land leaves.x)] \\
	[bins.p \implies ptot.p &= BinOp.(op.p).(ptot.(left.p)).(ptot.(right.p))] \\
	[leaves.p \implies ptot.p & = Word.(w.p)] \\
	[\iter{+}{p}{ptot.p = x \land (bins.p \lor leaves.p)}{root.p} & = tree.x] 
\end{align*}

\division{3}{Stacks}

\division{3}{Memory Allocation}

\division{1}{Unary operators}

\division{1}{Brackets}

\division{1}{Complete Syntax}

\begin{align*}
		Expr \quad ::= & \quad Expr  \ \odot \ Expr  \\
		& | \quad \word \\
		& | \quad \langle \ Expr \ \rangle \\
		& | \quad \oplus Expr \\
		& | \quad \iter{\circledast}{IdLst}{Expr}{Expr} \\
		& | \quad \langle \ IdLst \ := \ ExprLst \ \rangle \\
		& ; \\
		IdLst \quad ::= & \quad IdLst, \ID \\
		ExprLst \quad ::= & \quad ExprLst, Expr \\
		& ; 
\end{align*}

\end{document}  